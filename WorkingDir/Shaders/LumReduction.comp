#version 430
/*
	**Luminance Reduction Shader**

	File Name	: LumReduction.comp
	Author		: Bora Yalciner
	Description	:

		Luminance Reduction shader is a parallel reduction shader
		that generates average luminance (although only adds luminance,
		division should be done outside of the kernel) and
		Max luminance value of the image.

		It assumes image is RGB[A] format and it converts It to YCbCr
		color space and uses Y as Luminance value.
		
*/

// Utilize Nvidia Shuffle Operations if avail
#extension GL_NV_shader_thread_shuffle: enable
#extension GL_NV_shader_thread_group: enable

// Defines
#define U_RES layout(location = 0)

#define T_IN_HDR_IMAGE layout(binding = 0)

#define SSB_OUTPUT layout(std430, binding = 0) coherent

// WorkGroup Dimension
#define WORK_X 16
#define WORK_Y 16
#define WORK_LINEAR (WORK_X * WORK_Y)

// Extension does not have compile time constant
// This may cahange in future (probably not)
#define NV_WRAP_SIZE 32

// Textures
uniform T_IN_HDR_IMAGE sampler2D tInImage;

// SSBOs
SSB_OUTPUT buffer LuminanceData
{
	uint outMaxLum;
	uint outAvgLum;
};

// Uniforms
U_RES uniform ivec2 resolution;

// Shared Variables
#ifdef GL_NV_shader_thread_shuffle
#define TOTAL_WARP_ON_BLOCK (WORK_LINEAR / NV_WRAP_SIZE)
shared float reduceMaxBuffer[TOTAL_WARP_ON_BLOCK];
shared float reduceAvgBuffer[TOTAL_WARP_ON_BLOCK];
#else
shared float reduceBuffer[WORK_LINEAR / 2];
#endif

// Functions
float ComputeLuminance(in vec4 color)
{
    // https://en.wikipedia.org/wiki/Relative_luminance
    // RBG should be in linear space
    return (0.2120f * color.r +
            0.7150f * color.g +
            0.0722f * color.b);
}

void AtomicAddToSSBO(float val)
{
	uint prevVal, newVal;
	uint readVal = outAvgLum;
	do 
	{
		prevVal = readVal;
		newVal = floatBitsToUint(uintBitsToFloat(readVal) + val);
		readVal = atomicCompSwap(outAvgLum, prevVal, newVal);
	} while(readVal != prevVal);
}

void AtomicMaxToSSBO(float val)
{
	uint prevVal, newVal;
	uint readVal = outAvgLum;
	do 
	{
		prevVal = readVal;
		newVal = floatBitsToUint(max(uintBitsToFloat(readVal),val));
		readVal = atomicCompSwap(outMaxLum, prevVal, newVal);
	} while(readVal != prevVal);
}

void ReduceBlockNV(out float maxLum, out float avgLum,
				   in float lum)
{
	//Do 
	float localMaxLum = lum;
	float localAvgLum = lum;
		
	for(uint offset = NV_WRAP_SIZE / 2; offset > 0; offset >>= 1)
	{		
		float warpMaxLum, warpAvgLum;
		warpMaxLum = shuffleDownNV(localMaxLum, offset, NV_WRAP_SIZE);
		warpAvgLum = shuffleDownNV(localMaxLum, offset, NV_WRAP_SIZE);

		localMaxLum = max(warpMaxLum, localMaxLum);
		localAvgLum = warpAvgLum + localAvgLum;		
	}
	
	if(gl_ThreadInWarpNV == 0)
	{
		reduceMaxBuffer[gl_WarpIDNV] = localMaxLum;
		reduceAvgBuffer[gl_WarpIDNV] = localAvgLum;
	}
	memoryBarrierShared();
	barrier();

	// Only first warp (on that warp 8 thread will do the last reduce)
	if(gl_WarpIDNV == 0 &&
	   gl_ThreadInWarpNV < TOTAL_WARP_ON_BLOCK)
	{
		localMaxLum = reduceMaxBuffer[gl_ThreadInWarpNV];
		localAvgLum = reduceAvgBuffer[gl_ThreadInWarpNV];

		// Do one more pass of warp reduce
		for(uint offset = TOTAL_WARP_ON_BLOCK / 2; offset > 0; offset >>= 1)
		{		
			float warpMaxLum, warpAvgLum;
			warpMaxLum = shuffleDownNV(localMaxLum, offset, TOTAL_WARP_ON_BLOCK);
			warpAvgLum = shuffleDownNV(localMaxLum, offset, TOTAL_WARP_ON_BLOCK);

			localMaxLum = max(warpMaxLum, localMaxLum);
			localAvgLum = warpAvgLum + localAvgLum;		
		}
		if(gl_ThreadInWarpNV == 0)
		{
			maxLum = localMaxLum;
			avgLum = localAvgLum;
		}
	}
}

void ReduceBlockGeneric(out float maxLum, out float avgLum,
				        in float lum)
{

}

void ReduceBlock(out float maxLum, out float avgLum,
				 in float lum)
{
	// Utilize Warp Intrinsics on Nvidia GPUs
	#ifdef GL_NV_shader_thread_shuffle
	ReduceBlockNV(maxLum, avgLum, lum);
	#else 
	#error "NV Card Required"
	ReduceBlockGeneric(maxLum, avgLum, lum)
	#endif
}

// 16x16 block is always nice
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main(void)
{
	// Call logic is per pixel
	uvec2 globalId = gl_GlobalInvocationID.xy;
	// Generate pixelIds
	ivec2 pixId = ivec2(globalId);

	// Skip out of image threads
	if(any(greaterThanEqual(globalId, resolution))) return;

	// Read from current buffer buffers
	vec4 colorIn = texelFetch(tInImage, pixId, 0);

	float luminance = ComputeLuminance(colorIn);

	luminance = 1.0f;
	float maxLum, avgLum;
	ReduceBlock(maxLum, avgLum, luminance);

	// Local main thread will write to global memory
	// in an atomic manner. 
	// Normally for large images that does not fit into single block
	// (which most of the images are) you call this function again 
	// with a newly generated image (but it is more complex)
	// instead we atomically combine each blocks result
	if(all(equal(gl_LocalInvocationID.xy, uvec2(0))))
	{
		// No support for
		AtomicAddToSSBO(avgLum);
		AtomicMaxToSSBO(maxLum);
	}
}