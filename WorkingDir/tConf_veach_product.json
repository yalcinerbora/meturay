{

    //"TracerTypeName": "PathTracer",
    "TracerTypeName": "WFPGTracer",

    "TracerOptions":
    {
        //================//
        //    Generic     //
        //================//
        "Samples"               : 1,            // Sample for each pixel for every iteration
        "MaxDepth"              : 4,            // Maximum amount of depth can a path traverse
        "RussianRouletteStart"  : 4,            // Implictly disable RR for first "n" depths
        "NEESampler"            : "Uniform",    // Light sampler name

        "NextEventEstimation"   : false,        // Do NEE (Cast a shadow ray) from every depth
        "DirectLightMIS"        : false,        // Combine NEE and Path Rays using "Multiple Importance Sampling"

        //=======================//
        //  Path Tracer Related  //
        //=======================//
        "RunAsMegaKernel"       : false,        // Instead of doing a wavefront style of rendering, call
                                                // single monolithic kernel for material evaluation.
                                                // Ray casting is still seperate though.
                                                // This style of rendering is just for testing
                                                // and it should be slower than partitioning rays and calling
                                                // seperate kernels for each material type.
        //==================//
        //   WFPG Related   //
        //==================//
        "OctreeLevel"               : 8,            // Leaf level of the SVO (i.e. 9 means 512x512x512 resolution etc.)
        "MinRayBinLevel"            : 5,            // Rays that are hit during path tracing, will be partitioned
                                                    // at most to this level of the SVO
                                                    // If not enough rays are present on a voxel (after hit),
                                                    // that voxel will collapse to its parent until "BinRayCount"
                                                    // is reached. This parameter is upper limit of that recursion.
        "BinRayCount"               : 512,          // Amount of rays that deemed enough for creating radiance field on that SVO node.
                                                    // If this amount could not be reached, "MinBinLevel" will be the upper limit
        "DoProductPathGuiding"      : true,         // Do product path guiding.
                                                    // Product field resolution is fixed and it is 8x8 (can be changed from the code
                                                    // however; it is compile time constant for performance reasons)
                                                    // Generated radiance field will be multiplied by this 8x8 product
                                                    // to create outer layer field and sampling will be done in two phase
                                                    // (i.e. 32x32 radiance field will have 8x8 outer field and each of these values
                                                    // will have 4x4 inner field.)

        // Radiance field blurring
        "RFieldFilterAlpha"   : 0.6,    // Gaussian Filter Alpha value, used to blur the generated radiance field per region
        // OptiX SVO Tracing
        "OptiXTraceSVO" : true,         // Utilize Optix for SVO tracing, the system should have compiled with OptiX mode enabled
                                        // This system technically does not utilize shared memory but uses a small heap enough to fully saturate the GPU
                                        // instead of cone tracing directly from the kernel. (Optix Does not have shared memory support)
                                        // Utilizes "double buffering" (2x radiance cache (enough to saturate the GPU), cuda kernel does read over the buffer
                                        // while other one is generated by the optix kernel)
        "UseSceneAccelerator" : true,   // If OptiXTrace is set Scene Accelerator is used for tracing instead of SVO. Otherwise it has not effect
        "OptixTraceBufferSize" : 64,    // Radiance buffer size which will be used instead of shared memory for communicating data between OptiX Launch and
                                        // Path Guiding Kernel. It is in megabytes (MiB)

        "RenderMode"        : "Render",     // Normal rendering use SVO as path guider, do classic
                                            // path tracing (NEE and Direct Light MIS according to the other parameters)
        // PG <=> BxDF MIS Parameters
        "SkipPG"              : false,      // Only use BxDF to generate samples (no MIS)
        "PurePG"              : false,       // Generate samples only using WFPG path guiding (no MIS)
                                            // Both of these flags still do NEE and MIS combination (if appropirate flags are set)
        "BXDF-GuideMISRatio"  : 0.5,        // One-sample MIS ratio between BXDF and the Path Guider

        // Test (Not used)
        "GuidingDisableRatio" : 0.0,       // Only do guiding if region value greater than this value

        // Misc
        "WeightedCombineSamples" : true,    // Combine the samples with "PT First" heuristic
        "AdjustParallax":   false,          // Do Parallax Adjustment on the sampled rays that used PG field
        "GuideBounceAmount" : 3,            // Only guide first n bounces
        // Special Debug Parameters
        "SVORenderLevel"      : 0,      // Query the SVO up to this parameter when
                                        // "RenderMode" is either "SVORadiance", "SVONormal" or
                                        // "SVOFalseColor"
                                        // Parameter is offset from the leaf,
                                        // meaning:
                                        //   "0": Query up to leaf,
                                        //   "1": Query up to one level "above" the leaf (towards root),
                                        //   and so on.
        "SVODebugRenderIter"  : 2048,   // Do full path tracing "SVODebugRenderIter" times
                                        // then stop path tracing, this parameter only considered
                                        // when "RenderMode" is "SVORadiance"
        // Initialization Parameters
        "OmitDirectRadiance" : false,   // Initially do not accumulate light radiance on voxels
        "InitialSVO"          : "",     // Unless empty, tracer will load this svo instead of generating a new SVO

        //===================//
        // Path Guide Common //
        //===================//
        "PGDumpDataStruct"              : false,        // When set true, this path guiding tracer will dump its data structure
        "PGDataStructDumpIntervalExp"   : 2,            // (dump data structure every 2^i iterations)
        "PGDataStructDumpName"          : "wfpg_svo"    // Name of the dump file it will be prefixed by the iteration number
    },

    "TracerParameters":
    {
        "seed"          : 3,        // Meta seed
        "verbose"       : false,    // Verbose is not used currently, it will provide extra info
        "forceOptiX"    : true      // Enforce using optix, if set false, scene definition "accelerators" will be used
                                    // These accelerators are primitive and in software and should not be used unless you dont have
                                    // Geforce 1XXX series of cards or higher
    },

    "TracerDLL":
    {
        "name"  : "TracerCUDA",
        "entry" : "GenerateTracerSystem",
        "exit"  : "DeleteTracerSystem"
    },

    "SurfaceLoaders":
    [
        {
            "name"  : "AssimpSurfaceLoaders",
            "entry" : "GenerateAssimpPool",
            "exit"  : "DeleteAssimpPool",
            "regex" : ".*"
        },
        {
            "name"  : "GFGSurfaceLoader",
            "entry" : "GenerateGFGPool",
            "exit"  : "DeleteGFGPool",
            "regex" : ".*"
        }
    ],

    // Filter is optional (Not currently)
    // Defaults to box filter with radius of half pixel
    "FilterOptions":
    {
        // // Tent Filter
        "type": "Tent",
        "radius": 1.0
    },
    // TODO: Add multi-gpu heuristics
    // "Single GPU" does not partition the materials between GPUs.
    "ScenePartitionType": "SINGLE_GPU"
}


