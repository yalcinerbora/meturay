#pragma once

#include <vector>
#include <array>
#include <set>
#include <map>

#include "Vector.h"
#include "Matrix.h"
#include "SceneError.h"
#include "Types.h"
#include "HitStructs.h"

using NodeId = uint32_t;        // Node Id is generic name of the id logic
using MaterialId = uint32_t;    // Material Id represent material of some kind 
using SurfaceDataId = uint32_t; // Surface Id represent up to "MaxPrimitivePerSurface"
                                // material-primitive pairings of some kind

using NodeIndex = uint32_t;     // Node index is the index of the node that is on the list
                                // This is unique only for each type. (Materials, Primitives etc.)
using InnerIndex = uint32_t;    // Inner Index is sub index of the node
                                // Each node can define multiple ids

using TypeIdPair = std::pair<std::string, uint32_t>;
using IdPair = std::pair<uint32_t, uint32_t>;
using IdPairs = std::array<IdPair, SceneConstants::MaxPrimitivePerSurface>;

class SceneNodeI;

struct AccelGroupData
{
    std::string                     accelType;
    std::string                     primType;
    std::map<uint32_t, IdPairs>     matPrimIdPairs;
    std::unique_ptr<SceneNodeI>     accelNode;
};

struct MatBatchData
{
    std::string             primType;
    std::string             matType;
    std::set<MaterialId>    matIds;
};

// Overall all material key listings of the scene
// This is generated by distributor which has access to overall node and GPUs
// on nodes etc.
// Main node (or any node with the same code) will generate partitioning
// of materials with this HitKey - Type Pair
using MaterialKeyListing = std::map<TypeIdPair, HitKey>;

struct LightStruct
{
    std::string     typeName;
    uint32_t        matId;
};

using TransformStruct = Matrix4x4;

struct SurfaceStruct
{
    uint32_t        acceleratorId;
    uint32_t        transformId;
    IdPairs         matPrimPairs;
    int8_t          pairCount;
};