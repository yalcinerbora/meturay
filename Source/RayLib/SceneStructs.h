#pragma once

#include <vector>
#include <array>
#include <set>
#include <map>

#include "Vector.h"
#include "Matrix.h"
#include "SceneError.h"
#include "Types.h"
#include "HitStructs.h"

using MaterialId = uint32_t;
using SurfaceId = uint32_t;
using SurfaceDataId = uint32_t;

using TypeIdPair = std::pair<std::string, uint32_t>;
using IdPairing = std::pair<uint32_t, uint32_t>;
using IdTriplet = std::tuple<uint32_t, uint32_t, uint32_t>;
using IdPairings = std::array<IdPairing, SceneConstants::MaxSurfacePerAccelerator>;

struct AccelGroupData
{
	std::string						accelType;
	std::string						primType;
	std::map<uint32_t, IdPairings>	matPrimIdPairs;
};

struct MatBatchData
{
	std::string			primType;
	std::string			matType;
	std::set<uint32_t>	matIds;
};

// List of Accelerator or Material Batches
// That is required by this scene
// 
// Accel Groups and Batches have one to one relationship.
// Material and its batcher may have one to many reltionship depending on the
// GPU and Node count (but most of the time there is at most #GPU batches  on each
// Node)
//
// These information will be used to determine the material partitioning and how each
// of the materials will be called by the GPU
using RequiredAccelBatches = std::map<std::string, AccelGroupData>;
using RequiredMatBatches = std::map<std::string, MatBatchData>;

// Batch Key Ids for material batches and list of materials
using RequestedMatBatches = std::map<uint32_t, MatBatchData>;
using RequestedAccelBatches = std::map<uint32_t, AccelGroupData>;
// Batch Key Id -> GPU id pairings for materials
using MatBatchGPUPairings = std::map<uint32_t, int>;

// Overall all material key listings of the scene
// This is generated by distributor which has access to overall node and GPUs
// on nodes etc.
// Main node (or any node with the same code) will generate partitioning
// of materials with this HitKey - Type Pair
using MaterialKeyListing = std::map<TypeIdPair, HitKey>;

enum class LightType
{
	POINT,
	DIRECTIONAL,
	SPOT,
	RECTANGULAR
};

struct LightStruct
{
	LightType t;
	union
	{
		struct
		{
			Vector3f	position;
			float		intensity;
			Vector3f	color;
		} point;
		struct
		{
			Vector3f	direction;
			float		intensity;
			Vector3f	color;
		} directional;
		struct
		{
			Vector3f	position;
			float		coverageAngle;
			Vector3f	direction;
			float		falloffAngle;
			Vector3f	color;
			float		intensity;
		} spot;
		struct
		{
			Vector3f	position;
			float		red;
			Vector3f	edge0;
			float		green;
			Vector3f	edge1;
			float		blue;
			float		intensity;
		} rectangular;
	};
};

using TransformStruct = Matrix4x4;

struct SurfaceStruct
{
	std::string		acceleratorType;
	uint32_t		transformId;	
	IdPairings		matPrimPairs;
	int8_t			pairCount;
};

struct PrimitiveStruct
{
	struct PrimitiveData
	{
		std::string logic;		// Logic of the data (used by accelerator / material)
		uint32_t intake;		// Intake index (if data is stored multiple linear portions)
		uint32_t stride;		// Byte stride of the data
		uint32_t offset;		// Byte offset from the start of the index
		DataType type;			// Data type
	};

	// Members
	std::vector<PrimitiveData>	dataDefinitions;
	std::string					type;
	uint32_t					id;
};

//inline bool SurfaceStruct::operator<(const SurfaceStruct& right)
//{
//	bool case0 = primitiveId < right.primitiveId;
//	bool case1 = (primitiveId == right.primitiveId &&
//				  acceleratorId < right.acceleratorId);
//	return (case0 || case1);
//}
