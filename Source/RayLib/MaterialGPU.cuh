#pragma once



#include "RayStructs.h"
#include "Random.cuh"


template <class Surface, class HitReg, class PrimitiveData>
__device__ Surface(*SurfaceFunc)(const HitReg& hit,
								 const PrimitiveData& gPrimData);

template <class Surface, class MaterialData>
__device__ void(*ShadeFunc)(// Output rays
							RayGMem* outRays,
							const uint32_t maxOutRay,
							// Input ray and surface
							const RayReg& ray,
							const Surface& surface,
							const MaterialData& gMatData,
							RandomGPU& rng);

// This is fundemental Material traversal shader
// These kernels are generated by custom Surface Fetch and Shade Functions
// and Custom Primitives
template <class Surface, 
		  class HitGMem, class HitReg,
		  class MaterialData, class PrimitiveData,
		  SurfaceFunc<Surface, HitReg> SurfFunc,
		  ShadeFunc<Surface, MaterialData> ShadeFunc>
__global__ void KCMaterialShade(RayGMem* gOutRays,
								const uint32_t maxOutRay,
								// Ray Related
								const RayGMem* gInRays,
								const HitGMem gHits,
								const uint32_t rayCount,
								// RNG Related
								uint32_t* gRNGStates,
								// Material Related
								const MaterialData gMatData,
								// Primitive Related
								const PrimitiveData gPrimData)
{
	// Pre-grid stride loop
	// RNG is allocated for each SM (not for each thread)
	__shared__ uint32_t sRNGStates[];
	RandomGPU rng(gRNGStates, sRNGStates);

	// Grid Stride Loop
	for(uint32_t globalId = blockIdx.x * blockDim.x + threadIdx.x;
		globalId < rayCount; i += blockDim.x * gridDim.x)
	{
		// Load Input to Registers
		RayReg ray(rays, globalId);
		HitReg hit(hits, globalId);
		Surface surface = SurfFunc(hit, gPrimData);

		// Determine Output Location
		RayGMem* gLocalOut = gOutRays * globalId * maxOutRay;
		
		// Actual Shading
		ShadeFunc(// Output rays
				  gLocalOut,
				  maxOutRay,
				  // Input ray and surface
				  ray,
				  surface,
				  gMatData,
				  rng);
	}
}