#pragma once

#include "HitStructs.cuh"
#include "RayStructs.h"
#include "Random.cuh"

template <class Surface, class HitReg, class PrimitiveData>
using SurfaceFunc = Surface(*)(const HitReg& hit,
							   const PrimitiveData& gPrimData,
							   const uint32_t innerPrimitiveId);

template <class Surface, class RayAuxiliary, class MaterialData>
using ShadeFunc = __device__ void(*)(// Output
									 RayGMem* gOutRays,
									 RayAuxiliary* gOutRayAux,
									 const uint32_t maxOutRay,
									 // Input as registers
									 const RayReg& ray,
									 const Surface& surface,
									 const RayAuxiliary& aux,									 
									 // 
									 RandomGPU& rng,
									 // Input as global memory
									 const MaterialData& gMatData,
									 const MatId& matId);

// This is fundemental Material traversal shader
// These kernels are generated by custom Surface Fetch and Shade Functions
// and Custom Primitives
//template <class Surface, class RayAuxiliary,
//			class HitGMem, class HitReg,
//			class MaterialData, class PrimitiveData,
//			SurfaceFunc<Surface, HitReg, PrimitiveData> SurfFunc,
//			MatIdFetchFunc<HitReg> MatFunc,
//			ShadeFunc<Surface, PrimitiveData, MaterialData> ShadeFunc>
template <class TLogic, class PGroup, class MGroup, class BGroup>
__global__ void KCMaterialShade(// Output
								RayGMem* gOutRays,
								TLogic::RayAuxiliary* gOutRayAux,
								const uint32_t maxOutRay,
								// Input								
								const RayGMem* gInRays,
								const TLogic::RayAuxiliary* gInRayAux,
								const PrimitiveId* gPrimitiveId,
								const HitStructPtr gHitStructs,
								//
								const HitKey* gMatIds,
								const RayId* gRayIds,
								//
								const uint32_t rayCount,								
								RNGGMem gRNGStates,
								// Material Related
								const MGroup::MaterialData matData,
								// Primitive Related
								const PGroup::PrimitiveData primData)
{
	// Pre-grid stride loop
	// RNG is allocated for each SM (not for each thread)
	__shared__ uint32_t sRNGStates[];
	RandomGPU rng(gRNGStates.state, sRNGStates);

	// Grid Stride Loop
	for(uint32_t globalId = blockIdx.x * blockDim.x + threadIdx.x;
		globalId < rayCount; i += blockDim.x * gridDim.x)
	{
		const RayId rayId = gRayIds[globalId];
		
		// Load Input to Registers
		const RayReg ray(gInRays, rayId);
		const TLogic::RayAuxiliary aux = gInRayAux[rayId];
		const HitId hitId = dHitIds[rayId];

		// Generate surface data from hit
		const PGroup::HitReg hit(gHitStructs, rayId);
		const MGroup::Surface surface = MGroup::SurfFunc(hit, gPrimData,
														 hitId.primitiveIdInner);

		// Determine Output Location
		RayGMem* gLocalRayOut = gOutRays + globalId * maxOutRay;
		RayAuxiliary gLocalAuxOut = gOutRayAux + globalId * maxOutRay;
		// Actual Shading
		MGroup::ShadeFunc(// Output
						  gLocalRayOut,
						  gLocalAuxOut,
						  maxOutRay,
						  // Input as registers
						  ray,
						  surface,
						  aux,
						  //
						  rng,
						  // Input as global memory
						  MGroup::gMatData,
						  hitId.materialIdInner);
	}
}